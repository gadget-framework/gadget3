<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Structure of a gadget3 model • gadget3</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Structure of a gadget3 model">
<meta property="og:description" content="gadget3">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">gadget3</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.3.999</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/model-debugging.html">Debugging a gadget3 model</a>
    </li>
    <li>
      <a href="../articles/model_structure.html">Structure of a gadget3 model</a>
    </li>
    <li>
      <a href="../articles/tmb-gotchas.html">Gotchas and quirks of TMB</a>
    </li>
    <li>
      <a href="../articles/writing_actions.html">Writing G3 Actions</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="model_structure_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Structure of a gadget3 model</h1>
            
      
      
      <div class="hidden name"><code>model_structure.Rmd</code></div>

    </div>

    
    
<p>The following describes the structure of a gadget3 model, from the bottom up.</p>
<div id="r-formula-or-the-tilde-operator" class="section level2">
<h2 class="hasAnchor">
<a href="#r-formula-or-the-tilde-operator" class="anchor"></a>R formula, or the tilde operator</h2>
<p>Crucial to gadget3 is the <a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/formula.html">R formula</a>, created using the tilde operator (<code><a href="https://rdrr.io/r/base/tilde.html">~</a></code>). These get used in several places in R for various things, but at their core the tilde operator stores the R code on the left and right hand sides, as well as the environment it was created in, which amounts to all variables defined at the time.</p>
<p>For example, let’s declare a function that produces a formula, and make some:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">get_formula</span> <span class="op">&lt;-</span> <span class="kw">function</span> <span class="op">(</span><span class="va">size</span><span class="op">)</span> <span class="op">{</span>
    <span class="co"># NB: The reason we make a function here is so we have an isolated environment</span>
    <span class="co"># to make examples cleaner.</span>
    <span class="va">cows</span> <span class="op">&lt;-</span> <span class="va">size</span> <span class="op">*</span> <span class="fl">2</span>
    <span class="va">pigs</span> <span class="op">&lt;-</span> <span class="va">size</span> <span class="op">*</span> <span class="fl">4</span>
    <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="op">~</span><span class="va">cows</span> <span class="op">+</span> <span class="va">pigs</span><span class="op">)</span>
<span class="op">}</span>
<span class="va">f</span> <span class="op">&lt;-</span> <span class="fu">get_formula</span><span class="op">(</span><span class="fl">8</span><span class="op">)</span>
<span class="va">g</span> <span class="op">&lt;-</span> <span class="fu">get_formula</span><span class="op">(</span><span class="fl">5</span><span class="op">)</span></code></pre></div>
<p><code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> shows <code>f</code> contains the formula’s code (not the result of cows + pigs), and has an environment attached:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="va">f</span><span class="op">)</span></code></pre></div>
<pre><code>## Class 'formula'  language ~cows + pigs
##   ..- attr(*, ".Environment")=&lt;environment: 0x55dd64113350&gt;</code></pre>
<p>We can look into this environment, and see the values that got set for cows &amp; pigs:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">as.list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/environment.html">environment</a></span><span class="op">(</span><span class="va">f</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## List of 3
##  $ pigs: num 32
##  $ cows: num 16
##  $ size: num 8</code></pre>
<p>We can do similarly for <code>g</code>, and see the results are different:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/str.html">str</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">as.list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/environment.html">environment</a></span><span class="op">(</span><span class="va">g</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## List of 3
##  $ pigs: num 20
##  $ cows: num 10
##  $ size: num 5</code></pre>
<p>Note that:</p>
<ul>
<li>R hasn’t at any point worked out <code>cows + pigs</code>, the code was stored for later use.</li>
<li>The environment (i.e. all variables defined at that point) is “remembered”</li>
</ul>
<p>A g3 model at it’s core is a list of formula objects that make up the model. We can even use Gadget3 to compile our simple example above into an R function:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/run_r.html">g3_to_r</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">f</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## function (param) 
## {
##     cows &lt;- 16
##     pigs &lt;- 32
##     while (TRUE) {
##         cows + pigs
##     }
##     stop("Should have return()ed somewhere in the loop")
## }
## &lt;environment: 0x55dd63f06620&gt;
## attr(,"class")
## [1] "g3_r"     "function"
## attr(,"actions")
## attr(,"actions")[[1]]
## ~cows + pigs
## &lt;environment: 0x55dd64113350&gt;</code></pre>
<p>…or a TMB template:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/run_tmb.html">g3_to_tmb</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">f</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## #include &lt;TMB.hpp&gt;
## 
## namespace map_extras {
##     // at(), but throw (err) if item isn't available
##     template&lt;class Type, class KeyType&gt;
##     Type at_throw(std::map&lt;KeyType, Type&gt; map_in, KeyType key_in, std::string err) {
##             try {
##                 return map_in.at(key_in);
##             } catch (const std::out_of_range&amp;) {
##                 throw std::runtime_error("Out of range: " + err);
##             }
##     }
## 
##     // at(), but return def if item isn't available
##     template&lt;class Type, class KeyType&gt;
##     Type at_def(std::map&lt;KeyType, Type&gt; map_in, KeyType key_in, Type def) {
##             try {
##                 return map_in.at(key_in);
##             } catch (const std::out_of_range&amp;) {
##                 return def;
##             }
##     }
## }
## 
## template&lt;class Type&gt;
## Type objective_function&lt;Type&gt;::operator() () {
##     Type cows = (double)(16);
##     Type pigs = (double)(32);
## 
##     while (true) {
##         cows + pigs;
##     }
##     abort();  // Should have returned somewhere in the loop
## }</code></pre>
<p>Obviously this in itself isn’t a very useful function, but you can see that the environment for the formula has provided the initial values for the variables, and the code itself has been put into the main loop.</p>
<p>Also note that, despite appearances, we’re not generically converting R into C++. There’s a subset of R that gadget3 understands and knows how to convert. Using R libraries isn’t possible, for example. To simplify scoping rules, we assume variables are either global, and should have different names, or are iterators in loops, in which case they will be local to that loop.</p>
</div>
<div id="actions" class="section level2">
<h2 class="hasAnchor">
<a href="#actions" class="anchor"></a>Actions</h2>
<p>In reality you will never be providing formulae to insert into models directly, you’d be using the g3 action functions to generate these for you. All action functions, prefixed with <code>g3a_</code>, produce a list of formula objects—an action in gadget3 parlance. These are where the gadget functionality is implemented.</p>
<p>One of the simplest is <code>g3a_time</code>, which produces code that will count years/steps, and stop when the end of the time period is reached. For example:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/action_time.html">g3a_time</a></span><span class="op">(</span><span class="fl">1990</span>, <span class="fl">1999</span><span class="op">)</span></code></pre></div>
<pre><code>## $`000`
## ~{
##     debug_label("g3a_time")
##     cur_time &lt;- cur_time + 1L
##     if (strict_mode) 
##         assert_msg(is.finite(nll), "g3a_time: nll became NaN/Inf in previous timestep")
##     if (cur_time &gt; total_steps) {
##         g3_report_all()
##         return(nll)
##     }
##     cur_year &lt;- start_year + (cur_time%/%step_count)
##     cur_year_projection &lt;- cur_year &gt; end_year
##     cur_step &lt;- (cur_time%%step_count) + 1L
##     cur_step_final &lt;- cur_step == step_count
##     if (trace_mode) 
##         Rprintf("** Tick: %d-%d\n", cur_year, cur_step)
## }
## &lt;environment: 0x55dd6456bd28&gt;</code></pre>
<p>Like in the example above, the definitions are part of the formula’s environment, and if we compile it we see our years ending up in the code.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/run_r.html">g3_to_r</a></span><span class="op">(</span><span class="fu"><a href="../reference/action_time.html">g3a_time</a></span><span class="op">(</span><span class="fl">1990</span>, <span class="fl">1999</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## function (param) 
## {
##     assert_msg &lt;- function (expr, message) 
##     {
##         if (isFALSE(expr)) 
##             warning(message)
##     }
##     Rprintf &lt;- function (...) 
##     {
##         cat(sprintf(...))
##     }
##     cur_time &lt;- -1L
##     nll &lt;- 0
##     step_lengths &lt;- array(12L, dim = 1L, dimnames = NULL)
##     end_year &lt;- 1999L
##     start_year &lt;- 1990L
##     total_steps &lt;- length(step_lengths) * (end_year - start_year + 
##         0L) + length(step_lengths) - 1L
##     cur_year &lt;- 0L
##     step_count &lt;- length(step_lengths)
##     cur_year_projection &lt;- FALSE
##     cur_step &lt;- 0L
##     cur_step_final &lt;- FALSE
##     while (TRUE) {
##         {
##             comment("g3a_time")
##             cur_time &lt;- cur_time + 1L
##             if (FALSE) 
##                 assert_msg(is.finite(nll), "g3a_time: nll became NaN/Inf in previous timestep")
##             if (cur_time &gt; total_steps) {
##                 {
##                   attr(nll, "cur_step") &lt;- cur_step
##                   attr(nll, "cur_step_final") &lt;- cur_step_final
##                   attr(nll, "cur_time") &lt;- cur_time
##                   attr(nll, "cur_year") &lt;- cur_year
##                   attr(nll, "cur_year_projection") &lt;- cur_year_projection
##                 }
##                 return(nll)
##             }
##             cur_year &lt;- start_year + (cur_time%/%step_count)
##             cur_year_projection &lt;- cur_year &gt; end_year
##             cur_step &lt;- (cur_time%%step_count) + 1L
##             cur_step_final &lt;- cur_step == step_count
##             if (FALSE) 
##                 Rprintf("** Tick: %d-%d\n", cur_year, cur_step)
##         }
##     }
##     stop("Should have return()ed somewhere in the loop")
## }
## &lt;environment: 0x55dd64cc2b08&gt;
## attr(,"class")
## [1] "g3_r"     "function"
## attr(,"actions")
## attr(,"actions")$`000`
## ~{
##     debug_label("g3a_time")
##     cur_time &lt;- cur_time + 1L
##     if (strict_mode) 
##         assert_msg(is.finite(nll), "g3a_time: nll became NaN/Inf in previous timestep")
##     if (cur_time &gt; total_steps) {
##         g3_report_all()
##         return(nll)
##     }
##     cur_year &lt;- start_year + (cur_time%/%step_count)
##     cur_year_projection &lt;- cur_year &gt; end_year
##     cur_step &lt;- (cur_time%%step_count) + 1L
##     cur_step_final &lt;- cur_step == step_count
##     if (trace_mode) 
##         Rprintf("** Tick: %d-%d\n", cur_year, cur_step)
## }
## &lt;environment: 0x55dd637f6938&gt;</code></pre>
<p>In this case our years have been hard-coded, but their definitions could themselves be formula and the end result will be added to the model. For example:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/run_r.html">g3_to_r</a></span><span class="op">(</span><span class="fu"><a href="../reference/action_time.html">g3a_time</a></span><span class="op">(</span><span class="fl">1990</span>, <span class="op">~</span><span class="va">start_year</span> <span class="op">+</span> <span class="fl">4</span> <span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## function (param) 
## {
##     assert_msg &lt;- function (expr, message) 
##     {
##         if (isFALSE(expr)) 
##             warning(message)
##     }
##     Rprintf &lt;- function (...) 
##     {
##         cat(sprintf(...))
##     }
##     cur_time &lt;- -1L
##     nll &lt;- 0
##     step_lengths &lt;- array(12L, dim = 1L, dimnames = NULL)
##     start_year &lt;- 1990L
##     end_year &lt;- start_year + 4
##     total_steps &lt;- length(step_lengths) * (end_year - start_year + 
##         0L) + length(step_lengths) - 1L
##     cur_year &lt;- 0L
##     step_count &lt;- length(step_lengths)
##     cur_year_projection &lt;- FALSE
##     cur_step &lt;- 0L
##     cur_step_final &lt;- FALSE
##     while (TRUE) {
##         {
##             comment("g3a_time")
##             cur_time &lt;- cur_time + 1L
##             if (FALSE) 
##                 assert_msg(is.finite(nll), "g3a_time: nll became NaN/Inf in previous timestep")
##             if (cur_time &gt; total_steps) {
##                 {
##                   attr(nll, "cur_step") &lt;- cur_step
##                   attr(nll, "cur_step_final") &lt;- cur_step_final
##                   attr(nll, "cur_time") &lt;- cur_time
##                   attr(nll, "cur_year") &lt;- cur_year
##                   attr(nll, "cur_year_projection") &lt;- cur_year_projection
##                 }
##                 return(nll)
##             }
##             cur_year &lt;- start_year + (cur_time%/%step_count)
##             cur_year_projection &lt;- cur_year &gt; end_year
##             cur_step &lt;- (cur_time%%step_count) + 1L
##             cur_step_final &lt;- cur_step == step_count
##             if (FALSE) 
##                 Rprintf("** Tick: %d-%d\n", cur_year, cur_step)
##         }
##     }
##     stop("Should have return()ed somewhere in the loop")
## }
## &lt;environment: 0x55dd66265c20&gt;
## attr(,"class")
## [1] "g3_r"     "function"
## attr(,"actions")
## attr(,"actions")$`000`
## ~{
##     debug_label("g3a_time")
##     cur_time &lt;- cur_time + 1L
##     if (strict_mode) 
##         assert_msg(is.finite(nll), "g3a_time: nll became NaN/Inf in previous timestep")
##     if (cur_time &gt; total_steps) {
##         g3_report_all()
##         return(nll)
##     }
##     cur_year &lt;- start_year + (cur_time%/%step_count)
##     cur_year_projection &lt;- cur_year &gt; end_year
##     cur_step &lt;- (cur_time%%step_count) + 1L
##     cur_step_final &lt;- cur_step == step_count
##     if (trace_mode) 
##         Rprintf("** Tick: %d-%d\n", cur_year, cur_step)
## }
## &lt;environment: 0x55dd65d14688&gt;</code></pre>
</div>
<div id="stocks" class="section level2">
<h2 class="hasAnchor">
<a href="#stocks" class="anchor"></a>Stocks</h2>
<p>Beyond <code><a href="../reference/action_time.html">g3a_time()</a></code>, pretty much any action will be describing changes to a stock, possibly via. interacting with another stock (or fleet). To keep track of this state, we use <em>g3_stock</em> objects. These describe several things:</p>
<ul>
<li>The dimensions one would use if making an array to store data on that stock. For example if we want an array for number of individuals, what lengthgroups do we use? How many ages do we store? How many (and which) areas do we have?</li>
<li>What code do we need to iterate over the stock? Say I want to add 1 individual to each lengthgroup, how do I loop over all the other dimensions?</li>
<li>If looping over one stock, how do I find corresponding entries in another stock? For example, my fleet is only interested in prey that is in the same area.</li>
</ul>
<p>g3_stock objects can be created with either <code><a href="../reference/stock.html">g3_stock()</a></code> or <code><a href="../reference/stock.html">g3_fleet()</a></code>, the former will store lengthgroups, which fleets do not have.</p>
<p>Actions will store data about the stocks, for instance the current number of individuals, in arrays called stock instances. We can see what sort of arrays a stock will make by using <code>gadget3:::stock_instance</code>:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">ling_imm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/stock.html">g3_stock</a></span><span class="op">(</span><span class="st">'ling_imm'</span>, <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">50</span>, <span class="fl">10</span><span class="op">)</span><span class="op">)</span>
<span class="fu">gadget3</span><span class="fu">:::</span><span class="fu">stock_instance</span><span class="op">(</span><span class="va">ling_imm</span><span class="op">)</span></code></pre></div>
<pre><code>## length
##  len0 len10 len20 len30 len40 len50 
##    NA    NA    NA    NA    NA    NA</code></pre>
<p>To add complexity to our model, we can use other <code>g3s_</code> functions, such as <code><a href="../reference/stock_areas.html">g3s_livesonareas()</a></code> or <code><a href="../reference/stock_age.html">g3s_age()</a></code>, which adds area or age dimensions to a stock:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">ling_imm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/stock.html">g3_stock</a></span><span class="op">(</span><span class="st">'ling_imm'</span>, <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">50</span>, <span class="fl">10</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="fu"><a href="../reference/stock_age.html">g3s_age</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">10</span><span class="op">)</span>
<span class="fu">gadget3</span><span class="fu">:::</span><span class="fu">stock_instance</span><span class="op">(</span><span class="va">ling_imm</span><span class="op">)</span></code></pre></div>
<pre><code>##        age
## length  age3 age4 age5 age6 age7 age8 age9 age10
##   len0    NA   NA   NA   NA   NA   NA   NA    NA
##   len10   NA   NA   NA   NA   NA   NA   NA    NA
##   len20   NA   NA   NA   NA   NA   NA   NA    NA
##   len30   NA   NA   NA   NA   NA   NA   NA    NA
##   len40   NA   NA   NA   NA   NA   NA   NA    NA
##   len50   NA   NA   NA   NA   NA   NA   NA    NA</code></pre>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">ling_imm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/stock.html">g3_stock</a></span><span class="op">(</span><span class="st">'ling_imm'</span>, <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">50</span>, <span class="fl">10</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="fu"><a href="../reference/stock_areas.html">g3s_livesonareas</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span>
    <span class="fu"><a href="../reference/stock_age.html">g3s_age</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">10</span><span class="op">)</span>
<span class="fu">gadget3</span><span class="fu">:::</span><span class="fu">stock_instance</span><span class="op">(</span><span class="va">ling_imm</span><span class="op">)</span><span class="op">[</span>,,<span class="st">'age3'</span><span class="op">]</span></code></pre></div>
<pre><code>##        area
## length  area1 area2
##   len0     NA    NA
##   len10    NA    NA
##   len20    NA    NA
##   len30    NA    NA
##   len40    NA    NA
##   len50    NA    NA</code></pre>
<p>When you use an action such as <code><a href="../reference/action_grow.html">g3a_growmature()</a></code>, you provide g3_stock(s) to act on, and formula objects to fill in gaps in the code. <code><a href="../reference/action_grow.html">g3a_growmature()</a></code> will iterate over all areas/ages the stock has, and apply growth for each length group it finds.</p>
<p><code><a href="../reference/action_grow.html">g3a_growmature()</a></code> itself doesn’t care about areas or age, it just does the same to each. However, the formula you supply can. <code>age</code> and <code>area</code> variables will be set with the current age/area, which you can use when writing formula. For example:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">fn</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/run_r.html">g3_to_r</a></span><span class="op">(</span><span class="fu"><a href="../reference/action_grow.html">g3a_growmature</a></span><span class="op">(</span>
    <span class="va">ling_imm</span>,
    impl_f <span class="op">=</span> <span class="fu"><a href="../reference/action_grow.html">g3a_grow_impl_bbinom</a></span><span class="op">(</span>
        delta_len_f <span class="op">=</span> <span class="op">~</span><span class="va">age</span> <span class="op">*</span> <span class="fl">10</span>,
        delta_wgt_f <span class="op">=</span> <span class="op">~</span><span class="va">area</span> <span class="op">*</span> <span class="fl">20</span>,
        beta_f <span class="op">=</span> <span class="op">~</span><span class="fu"><a href="../reference/language.html">g3_param</a></span><span class="op">(</span><span class="st">"ling.bbin"</span><span class="op">)</span>,
        maxlengthgroupgrowth <span class="op">=</span> <span class="fl">4</span><span class="op">)</span>,
    transition_f <span class="op">=</span> <span class="op">~</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span>
<span class="va">fn</span></code></pre></div>
<pre><code>## function (param) 
## {
##     stopifnot("ling.bbin" %in% names(param))
##     growth_bbinom &lt;- function (delt_l, binn, beta) 
##     {
##         alpha &lt;- (beta * delt_l)/(binn - delt_l)
##         x &lt;- 0:binn
##         na &lt;- length(alpha)
##         n &lt;- length(x) - 1
##         alpha &lt;- rep(alpha, n + 1)
##         x &lt;- rep(x, each = na)
##         val &lt;- exp(lgamma(n + 1) + lgamma(alpha + beta) + lgamma(n - 
##             x + beta) + lgamma(x + alpha) - lgamma(n - x + 1) - 
##             lgamma(x + 1) - lgamma(n + alpha + beta) - lgamma(beta) - 
##             lgamma(alpha))
##         dim(val) &lt;- c(na, n + 1)
##         return(val)
##     }
##     avoid_zero_vec &lt;- function (a) 
##     {
##         (pmax(a * 1000, 0) + log1p(exp(pmin(a * 1000, 0) - pmax(a * 
##             1000, 0))))/1000
##     }
##     avoid_zero &lt;- function (a) 
##     {
##         (pmax(a * 1000, 0) + log1p(exp(pmin(a * 1000, 0) - pmax(a * 
##             1000, 0))))/1000
##     }
##     g3a_grow_apply &lt;- function (delta_l, delta_w, input_num, 
##         input_wgt) 
##     {
##         na &lt;- dim(delta_l)[[1]]
##         n &lt;- dim(delta_l)[[2]] - 1
##         avoid_zero_vec &lt;- function(a) {
##             (pmax(a * 1000, 0) + log1p(exp(pmin(a * 1000, 0) - 
##                 pmax(a * 1000, 0))))/1000
##         }
##         growth.matrix &lt;- array(0, c(na, na))
##         wgt.matrix &lt;- array(0, c(na, na))
##         for (lg in 1:na) {
##             if (lg == na) {
##                 growth.matrix[na, na] &lt;- sum(delta_l[lg, ])
##                 wgt.matrix[lg, lg:na] &lt;- delta_w[lg, 1:(na - 
##                   lg + 1)]
##             }
##             else if (lg + n &gt; na) {
##                 growth.matrix[lg, lg:(na - 1)] &lt;- delta_l[lg, 
##                   1:(na - lg)]
##                 growth.matrix[lg, na] &lt;- sum(delta_l[lg, (na - 
##                   lg + 1):(n + 1)])
##                 wgt.matrix[lg, lg:na] &lt;- delta_w[lg, 1:(na - 
##                   lg + 1)]
##             }
##             else {
##                 growth.matrix[lg, lg:(n + lg)] &lt;- delta_l[lg, 
##                   ]
##                 wgt.matrix[lg, lg:(n + lg)] &lt;- delta_w[lg, ]
##             }
##         }
##         growth.matrix &lt;- growth.matrix * as.vector(input_num)
##         wgt.matrix &lt;- growth.matrix * (wgt.matrix + as.vector(input_wgt))
##         return(array(c(Matrix::colSums(growth.matrix), Matrix::colSums(wgt.matrix)/avoid_zero_vec(Matrix::colSums(growth.matrix))), 
##             dim = c(na, 2)))
##     }
##     assert_msg &lt;- function (expr, message) 
##     {
##         if (isFALSE(expr)) 
##             warning(message)
##     }
##     ling_imm__minage &lt;- 3L
##     ling_imm__maxage &lt;- 10L
##     ling_imm__areas &lt;- model_data$ling_imm__areas
##     ling_imm__growth_l &lt;- array(NA, dim = c(0L, 0L), dimnames = NULL)
##     ling_imm__plusdl &lt;- 10
##     ling_imm__growth_w &lt;- array(NA, dim = c(0L, 0L), dimnames = NULL)
##     ling_imm__prevtotal &lt;- 0
##     ling_imm__num &lt;- array(0, dim = c(length = 6L, area = 2L, 
##     age = 8L), dimnames = list(length = c("len0", "len10", "len20", 
##     "len30", "len40", "len50"), area = c("area1", "area2"), age = c("age3", 
##     "age4", "age5", "age6", "age7", "age8", "age9", "age10")))
##     ling_imm__wgt &lt;- array(1, dim = c(length = 6L, area = 2L, 
##     age = 8L), dimnames = list(length = c("len0", "len10", "len20", 
##     "len30", "len40", "len50"), area = c("area1", "area2"), age = c("age3", 
##     "age4", "age5", "age6", "age7", "age8", "age9", "age10")))
##     while (TRUE) {
##         {
##             comment("g3a_grow for ling_imm")
##             for (age in seq(ling_imm__minage, ling_imm__maxage, 
##                 by = 1)) {
##                 ling_imm__age_idx &lt;- age - ling_imm__minage + 
##                   1L
##                 for (ling_imm__area_idx in seq_along(ling_imm__areas)) {
##                   area &lt;- ling_imm__areas[[ling_imm__area_idx]]
##                   {
##                     comment("Calculate length/weight delta matrices for current lengthgroups")
##                     ling_imm__growth_l &lt;- growth_bbinom(avoid_zero_vec((age * 
##                       10)/ling_imm__plusdl), 4, avoid_zero(param[["ling.bbin"]]))
##                     ling_imm__growth_w &lt;- area * 20
##                     if (FALSE) 
##                       ling_imm__prevtotal &lt;- sum(ling_imm__num[, 
##                         ling_imm__area_idx, ling_imm__age_idx])
##                     comment("Update ling_imm using delta matrices")
##                     {
##                       growthresult &lt;- g3a_grow_apply(ling_imm__growth_l, 
##                         ling_imm__growth_w, ling_imm__num[, ling_imm__area_idx, 
##                           ling_imm__age_idx], ling_imm__wgt[, 
##                           ling_imm__area_idx, ling_imm__age_idx])
##                       {
##                         ling_imm__num[, ling_imm__area_idx, ling_imm__age_idx] &lt;- growthresult[, 
##                           (1)]
##                         ling_imm__wgt[, ling_imm__area_idx, ling_imm__age_idx] &lt;- growthresult[, 
##                           (2)]
##                       }
##                     }
##                     if (FALSE) 
##                       assert_msg(~abs(ling_imm__prevtotal - sum(ling_imm__num[, 
##                         ling_imm__area_idx, ling_imm__age_idx])) &lt; 
##                         1e-04, "g3a_growmature: ling_imm__num totals are not the same before and after growth")
##                   }
##                 }
##             }
##         }
##     }
##     stop("Should have return()ed somewhere in the loop")
## }
## &lt;environment: 0x55dd64368d10&gt;
## attr(,"class")
## [1] "g3_r"     "function"
## attr(,"actions")
## attr(,"actions")$`005:ling_imm            :4e6ce20f8ec197c80cab`
## ~{
##     debug_label("g3a_grow for ling_imm")
##     for (age in seq(ling_imm__minage, ling_imm__maxage, by = 1)) g3_with(`:=`(ling_imm__age_idx, 
##         g3_idx(age - ling_imm__minage + 1L)), for (ling_imm__area_idx in seq_along(ling_imm__areas)) g3_with(`:=`(area, 
##         ling_imm__areas[[ling_imm__area_idx]]), {
##         debug_trace("Calculate length/weight delta matrices for current lengthgroups")
##         ling_imm__growth_l &lt;- growth_bbinom(avoid_zero_vec((age * 
##             10)/ling_imm__plusdl), 4, avoid_zero(g3_param("ling.bbin")))
##         ling_imm__growth_w &lt;- area * 20
##         if (strict_mode) 
##             ling_imm__prevtotal &lt;- sum(ling_imm__num[, ling_imm__area_idx, 
##                 ling_imm__age_idx])
##         debug_trace("Update ling_imm using delta matrices")
##         g3_with(`:=`(growthresult, g3a_grow_apply(ling_imm__growth_l, 
##             ling_imm__growth_w, ling_imm__num[, ling_imm__area_idx, 
##                 ling_imm__age_idx], ling_imm__wgt[, ling_imm__area_idx, 
##                 ling_imm__age_idx])), {
##             ling_imm__num[, ling_imm__area_idx, ling_imm__age_idx] &lt;- growthresult[, 
##                 g3_idx(1)]
##             ling_imm__wgt[, ling_imm__area_idx, ling_imm__age_idx] &lt;- growthresult[, 
##                 g3_idx(2)]
##         })
##         if (strict_mode) 
##             assert_msg(~abs(ling_imm__prevtotal - sum(ling_imm__num[, 
##                 ling_imm__area_idx, ling_imm__age_idx])) &lt; 1e-04, 
##                 "g3a_growmature: ling_imm__num totals are not the same before and after growth")
##     }))
## }
## &lt;environment: 0x55dd66e24668&gt;
## 
## attr(,"parameter_template")
## attr(,"parameter_template")$ling.bbin
## [1] 0</code></pre>
<p>…you can see our provided formula have been used to calculate <code>ling_imm__growth_l</code> and <code>ling_imm__growth_w</code>, and <code>age</code> and <code>area</code> are available to us thanks to the loops provided by the stock.</p>
<p>We can also define formulas and reference them. Gadget3 will add the definitions into the code where appropriate. For example:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">custom_delta_l</span> <span class="op">&lt;-</span> <span class="op">~</span><span class="va">area</span> <span class="op">*</span> <span class="fl">99</span>
<span class="va">custom_delta_w</span> <span class="op">&lt;-</span> <span class="op">~</span><span class="va">ling_imm__plusdl</span> <span class="op">*</span> <span class="fl">44</span>
<span class="va">fn</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/run_r.html">g3_to_r</a></span><span class="op">(</span><span class="fu"><a href="../reference/action_grow.html">g3a_growmature</a></span><span class="op">(</span>
    <span class="va">ling_imm</span>,
    impl_f <span class="op">=</span> <span class="fu"><a href="../reference/action_grow.html">g3a_grow_impl_bbinom</a></span><span class="op">(</span>
        delta_len_f <span class="op">=</span> <span class="op">~</span><span class="va">age</span> <span class="op">*</span> <span class="va">custom_delta_l</span> <span class="op">*</span> <span class="fl">10</span>,
        delta_wgt_f <span class="op">=</span> <span class="op">~</span><span class="va">area</span> <span class="op">*</span> <span class="va">custom_delta_w</span> <span class="op">*</span> <span class="fl">20</span>,
        beta_f <span class="op">=</span> <span class="op">~</span><span class="fu"><a href="../reference/language.html">g3_param</a></span><span class="op">(</span><span class="st">"ling.bbin"</span><span class="op">)</span>,
        maxlengthgroupgrowth <span class="op">=</span> <span class="fl">4</span><span class="op">)</span>,
    transition_f <span class="op">=</span> <span class="op">~</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span>
<span class="va">fn</span></code></pre></div>
<pre><code>## function (param) 
## {
##     stopifnot("ling.bbin" %in% names(param))
##     growth_bbinom &lt;- function (delt_l, binn, beta) 
##     {
##         alpha &lt;- (beta * delt_l)/(binn - delt_l)
##         x &lt;- 0:binn
##         na &lt;- length(alpha)
##         n &lt;- length(x) - 1
##         alpha &lt;- rep(alpha, n + 1)
##         x &lt;- rep(x, each = na)
##         val &lt;- exp(lgamma(n + 1) + lgamma(alpha + beta) + lgamma(n - 
##             x + beta) + lgamma(x + alpha) - lgamma(n - x + 1) - 
##             lgamma(x + 1) - lgamma(n + alpha + beta) - lgamma(beta) - 
##             lgamma(alpha))
##         dim(val) &lt;- c(na, n + 1)
##         return(val)
##     }
##     avoid_zero_vec &lt;- function (a) 
##     {
##         (pmax(a * 1000, 0) + log1p(exp(pmin(a * 1000, 0) - pmax(a * 
##             1000, 0))))/1000
##     }
##     avoid_zero &lt;- function (a) 
##     {
##         (pmax(a * 1000, 0) + log1p(exp(pmin(a * 1000, 0) - pmax(a * 
##             1000, 0))))/1000
##     }
##     g3a_grow_apply &lt;- function (delta_l, delta_w, input_num, 
##         input_wgt) 
##     {
##         na &lt;- dim(delta_l)[[1]]
##         n &lt;- dim(delta_l)[[2]] - 1
##         avoid_zero_vec &lt;- function(a) {
##             (pmax(a * 1000, 0) + log1p(exp(pmin(a * 1000, 0) - 
##                 pmax(a * 1000, 0))))/1000
##         }
##         growth.matrix &lt;- array(0, c(na, na))
##         wgt.matrix &lt;- array(0, c(na, na))
##         for (lg in 1:na) {
##             if (lg == na) {
##                 growth.matrix[na, na] &lt;- sum(delta_l[lg, ])
##                 wgt.matrix[lg, lg:na] &lt;- delta_w[lg, 1:(na - 
##                   lg + 1)]
##             }
##             else if (lg + n &gt; na) {
##                 growth.matrix[lg, lg:(na - 1)] &lt;- delta_l[lg, 
##                   1:(na - lg)]
##                 growth.matrix[lg, na] &lt;- sum(delta_l[lg, (na - 
##                   lg + 1):(n + 1)])
##                 wgt.matrix[lg, lg:na] &lt;- delta_w[lg, 1:(na - 
##                   lg + 1)]
##             }
##             else {
##                 growth.matrix[lg, lg:(n + lg)] &lt;- delta_l[lg, 
##                   ]
##                 wgt.matrix[lg, lg:(n + lg)] &lt;- delta_w[lg, ]
##             }
##         }
##         growth.matrix &lt;- growth.matrix * as.vector(input_num)
##         wgt.matrix &lt;- growth.matrix * (wgt.matrix + as.vector(input_wgt))
##         return(array(c(Matrix::colSums(growth.matrix), Matrix::colSums(wgt.matrix)/avoid_zero_vec(Matrix::colSums(growth.matrix))), 
##             dim = c(na, 2)))
##     }
##     assert_msg &lt;- function (expr, message) 
##     {
##         if (isFALSE(expr)) 
##             warning(message)
##     }
##     ling_imm__plusdl &lt;- 10
##     ling_imm__minage &lt;- 3L
##     ling_imm__maxage &lt;- 10L
##     ling_imm__areas &lt;- model_data$ling_imm__areas
##     ling_imm__growth_l &lt;- array(NA, dim = c(0L, 0L), dimnames = NULL)
##     ling_imm__growth_w &lt;- array(NA, dim = c(0L, 0L), dimnames = NULL)
##     ling_imm__prevtotal &lt;- 0
##     ling_imm__num &lt;- array(0, dim = c(length = 6L, area = 2L, 
##     age = 8L), dimnames = list(length = c("len0", "len10", "len20", 
##     "len30", "len40", "len50"), area = c("area1", "area2"), age = c("age3", 
##     "age4", "age5", "age6", "age7", "age8", "age9", "age10")))
##     ling_imm__wgt &lt;- array(1, dim = c(length = 6L, area = 2L, 
##     age = 8L), dimnames = list(length = c("len0", "len10", "len20", 
##     "len30", "len40", "len50"), area = c("area1", "area2"), age = c("age3", 
##     "age4", "age5", "age6", "age7", "age8", "age9", "age10")))
##     while (TRUE) {
##         {
##             custom_delta_w &lt;- (ling_imm__plusdl * 44)
##             {
##                 comment("g3a_grow for ling_imm")
##                 for (age in seq(ling_imm__minage, ling_imm__maxage, 
##                   by = 1)) {
##                   ling_imm__age_idx &lt;- age - ling_imm__minage + 
##                     1L
##                   for (ling_imm__area_idx in seq_along(ling_imm__areas)) {
##                     area &lt;- ling_imm__areas[[ling_imm__area_idx]]
##                     custom_delta_l &lt;- (area * 99)
##                     {
##                       comment("Calculate length/weight delta matrices for current lengthgroups")
##                       ling_imm__growth_l &lt;- growth_bbinom(avoid_zero_vec((age * 
##                         custom_delta_l * 10)/ling_imm__plusdl), 
##                         4, avoid_zero(param[["ling.bbin"]]))
##                       ling_imm__growth_w &lt;- area * custom_delta_w * 
##                         20
##                       if (FALSE) 
##                         ling_imm__prevtotal &lt;- sum(ling_imm__num[, 
##                           ling_imm__area_idx, ling_imm__age_idx])
##                       comment("Update ling_imm using delta matrices")
##                       {
##                         growthresult &lt;- g3a_grow_apply(ling_imm__growth_l, 
##                           ling_imm__growth_w, ling_imm__num[, 
##                             ling_imm__area_idx, ling_imm__age_idx], 
##                           ling_imm__wgt[, ling_imm__area_idx, 
##                             ling_imm__age_idx])
##                         {
##                           ling_imm__num[, ling_imm__area_idx, 
##                             ling_imm__age_idx] &lt;- growthresult[, 
##                             (1)]
##                           ling_imm__wgt[, ling_imm__area_idx, 
##                             ling_imm__age_idx] &lt;- growthresult[, 
##                             (2)]
##                         }
##                       }
##                       if (FALSE) 
##                         assert_msg(~abs(ling_imm__prevtotal - 
##                           sum(ling_imm__num[, ling_imm__area_idx, 
##                             ling_imm__age_idx])) &lt; 1e-04, "g3a_growmature: ling_imm__num totals are not the same before and after growth")
##                     }
##                   }
##                 }
##             }
##         }
##     }
##     stop("Should have return()ed somewhere in the loop")
## }
## &lt;environment: 0x55dd664e0370&gt;
## attr(,"class")
## [1] "g3_r"     "function"
## attr(,"actions")
## attr(,"actions")$`005:ling_imm            :66b9ec4f30b4ade3c3e0`
## ~g3_with(`:=`(custom_delta_w, (ling_imm__plusdl * 44)), {
##     debug_label("g3a_grow for ling_imm")
##     for (age in seq(ling_imm__minage, ling_imm__maxage, by = 1)) g3_with(`:=`(ling_imm__age_idx, 
##         g3_idx(age - ling_imm__minage + 1L)), for (ling_imm__area_idx in seq_along(ling_imm__areas)) g3_with(`:=`(area, 
##         ling_imm__areas[[ling_imm__area_idx]]), `:=`(custom_delta_l, 
##         (area * 99)), {
##         debug_trace("Calculate length/weight delta matrices for current lengthgroups")
##         ling_imm__growth_l &lt;- growth_bbinom(avoid_zero_vec((age * 
##             custom_delta_l * 10)/ling_imm__plusdl), 4, avoid_zero(g3_param("ling.bbin")))
##         ling_imm__growth_w &lt;- area * custom_delta_w * 20
##         if (strict_mode) 
##             ling_imm__prevtotal &lt;- sum(ling_imm__num[, ling_imm__area_idx, 
##                 ling_imm__age_idx])
##         debug_trace("Update ling_imm using delta matrices")
##         g3_with(`:=`(growthresult, g3a_grow_apply(ling_imm__growth_l, 
##             ling_imm__growth_w, ling_imm__num[, ling_imm__area_idx, 
##                 ling_imm__age_idx], ling_imm__wgt[, ling_imm__area_idx, 
##                 ling_imm__age_idx])), {
##             ling_imm__num[, ling_imm__area_idx, ling_imm__age_idx] &lt;- growthresult[, 
##                 g3_idx(1)]
##             ling_imm__wgt[, ling_imm__area_idx, ling_imm__age_idx] &lt;- growthresult[, 
##                 g3_idx(2)]
##         })
##         if (strict_mode) 
##             assert_msg(~abs(ling_imm__prevtotal - sum(ling_imm__num[, 
##                 ling_imm__area_idx, ling_imm__age_idx])) &lt; 1e-04, 
##                 "g3a_growmature: ling_imm__num totals are not the same before and after growth")
##     }))
## })
## &lt;environment: 0x55dd66098400&gt;
## 
## attr(,"parameter_template")
## attr(,"parameter_template")$ling.bbin
## [1] 0</code></pre>
<p>Note that <code>custom_delta_l</code> is recalculated every loop, since it uses <code>area</code>, whereas <code>custom_delta_w</code> is calculated once for the step.</p>
</div>
<div id="model-parameterization" class="section level2">
<h2 class="hasAnchor">
<a href="#model-parameterization" class="anchor"></a>Model parameterization</h2>
<p>In the <code>g3a_growmature</code> function above, we see a reference to <code><a href="../reference/language.html">g3_param("ling.bbin")</a></code>. The <code><a href="../reference/language.html">g3_param()</a></code> function is pseudo-code that specifies the model should accept a parameter at this point. In the R code, this has been converted to <code>param[["ling.bbin"]]</code>, so when we call our R function, we can provide a value, e.g. <code>fn(list(ling.bbin = 6))</code>. We can also use <code><a href="../reference/language.html">g3_param_vector()</a></code> to provide a model with a vector of values. See <code><a href="../reference/language.html">?g3_param</a></code> for more information on this and other functions available to you.</p>
<p>When converting to TMB, there are a lot more options for using the optimisation features it offers.</p>
</div>
<div id="combining-actions" class="section level2">
<h2 class="hasAnchor">
<a href="#combining-actions" class="anchor"></a>Combining actions</h2>
<p>Any useful model will have multiple actions, so the outputs from the <code>g3a_</code> functions need to be combined. To do this, you can pass a list of actions to any of the <code>g3_to_*</code> functions, for example:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">ling_model</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/run_r.html">g3_to_r</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>
    <span class="fu"><a href="../reference/action_age.html">g3a_age</a></span><span class="op">(</span><span class="va">ling_imm</span><span class="op">)</span>,
    <span class="fu"><a href="../reference/action_grow.html">g3a_growmature</a></span><span class="op">(</span>
        <span class="va">ling_imm</span>,
        impl_f <span class="op">=</span> <span class="fu"><a href="../reference/action_grow.html">g3a_grow_impl_bbinom</a></span><span class="op">(</span>
            delta_len_f <span class="op">=</span> <span class="op">~</span><span class="va">age</span> <span class="op">*</span> <span class="fl">10</span>,
            delta_wgt_f <span class="op">=</span> <span class="op">~</span><span class="va">area</span> <span class="op">*</span> <span class="fl">20</span>,
            beta_f <span class="op">=</span> <span class="op">~</span><span class="fu"><a href="../reference/language.html">g3_param</a></span><span class="op">(</span><span class="st">"ling.bbin"</span><span class="op">)</span>,
            maxlengthgroupgrowth <span class="op">=</span> <span class="fl">4</span><span class="op">)</span><span class="op">)</span>,
    <span class="fu"><a href="../reference/action_time.html">g3a_time</a></span><span class="op">(</span><span class="fl">1990</span>, <span class="fl">1999</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>A useful technique is to break down the actions into separate lists, e.g.</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">ling_imm_actions</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>
    <span class="fu"><a href="../reference/action_age.html">g3a_age</a></span><span class="op">(</span><span class="va">ling_imm</span><span class="op">)</span>,
    <span class="fu"><a href="../reference/action_grow.html">g3a_growmature</a></span><span class="op">(</span>
        <span class="va">ling_imm</span>,
        impl_f <span class="op">=</span> <span class="fu"><a href="../reference/action_grow.html">g3a_grow_impl_bbinom</a></span><span class="op">(</span>
            delta_len_f <span class="op">=</span> <span class="op">~</span><span class="va">age</span> <span class="op">*</span> <span class="fl">10</span>,
            delta_wgt_f <span class="op">=</span> <span class="op">~</span><span class="va">area</span> <span class="op">*</span> <span class="fl">20</span>,
            beta_f <span class="op">=</span> <span class="op">~</span><span class="fu"><a href="../reference/language.html">g3_param</a></span><span class="op">(</span><span class="st">"ling.bbin"</span><span class="op">)</span>,
            maxlengthgroupgrowth <span class="op">=</span> <span class="fl">4</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
<span class="va">time_actions</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>
    <span class="fu"><a href="../reference/action_time.html">g3a_time</a></span><span class="op">(</span><span class="fl">1990</span>, <span class="fl">1999</span><span class="op">)</span><span class="op">)</span>

<span class="va">ling_model</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/run_r.html">g3_to_r</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">ling_imm_actions</span>, <span class="va">time_actions</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>Your actions can be combined in any order, the reasons for why are in the next section.</p>
</div>
<div id="ordering-of-actions" class="section level2">
<h2 class="hasAnchor">
<a href="#ordering-of-actions" class="anchor"></a>Ordering of actions</h2>
<p>Gadget2 has a strict <a href="https://gadget-framework.github.io/gadget2/userguide/chap-order.html">Order of Calculations</a>, and re-ordering calculations may well have averse effects. Actions also have common steps to perform, for example overstocking for a prey has to be calculated, and calculated once, after each fleet has finished harvesting.</p>
<p>To manage this, formulas within an action are labelled with a string, for example:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">lln</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/stock.html">g3_fleet</a></span><span class="op">(</span><span class="st">'lln'</span><span class="op">)</span> <span class="op">%&gt;%</span> <span class="fu"><a href="../reference/stock_areas.html">g3s_livesonareas</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span><span class="op">(</span>
    <span class="fu"><a href="../reference/action_predate.html">g3a_predate_fleet</a></span><span class="op">(</span>
        <span class="va">lln</span>,
        <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">ling_imm</span><span class="op">)</span>,
        suitabilities <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>
            ling_imm <span class="op">=</span> <span class="fu"><a href="../reference/suitability.html">g3_suitability_exponentiall50</a></span><span class="op">(</span>
                <span class="op">~</span><span class="fu"><a href="../reference/language.html">g3_param</a></span><span class="op">(</span><span class="st">'ling.lln.alpha'</span><span class="op">)</span>,
                <span class="op">~</span><span class="fu"><a href="../reference/language.html">g3_param</a></span><span class="op">(</span><span class="st">'ling.lln.l50'</span><span class="op">)</span><span class="op">)</span>,
            ling_mat <span class="op">=</span> <span class="fu"><a href="../reference/suitability.html">g3_suitability_exponentiall50</a></span><span class="op">(</span>
                <span class="op">~</span><span class="fu"><a href="../reference/language.html">g3_param</a></span><span class="op">(</span><span class="st">'ling.lln.alpha'</span><span class="op">)</span>,
                <span class="op">~</span><span class="fu"><a href="../reference/language.html">g3_param</a></span><span class="op">(</span><span class="st">'ling.lln.l50'</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,
        catchability_f <span class="op">=</span> <span class="fu"><a href="../reference/action_predate.html">g3a_predate_catchability_totalfleet</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span>,
    <span class="co"># NB: step_find_desc finds a label within the formula</span>
    <span class="kw">function</span> <span class="op">(</span><span class="va">s</span><span class="op">)</span> <span class="fu">gadget3</span><span class="fu">:::</span><span class="fu">step_find_desc</span><span class="op">(</span><span class="va">s</span>, minor_steps <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## $`003:000:lln                 `
## [1] "Zero biomass-caught counter for lln"
## 
## $`003:000:ling_imm            `
## [1] "Zero total predation counter for ling_imm"
## 
## $`003:004:ling_imm            `
## [1] "Calculate ling_imm overconsumption coefficient"
## 
## $`003:002:lln                 :ling_imm            :3e19f1f5997cd960b5a2`
## [1] "Scale lln catch of ling_imm by total expected catch"
## 
## $`003:001:lln                 :ling_imm            :3e19f1f5997cd960b5a2`
## [1] "g3a_predate_fleet for ling_imm"
## 
## $`003:005:lln                 :ling_imm            `
## [1] "Revert to being total biomass (applying overconsumption in process)"
## 
## $`003:005:lln                 `
## [1] "Zero lln catch before working out post-adjustment value"
## 
## $`003:003:lln                 :ling_imm            `
## [1] "Temporarily convert to being proportion of totalpredate"</code></pre>
<p>We see each step has a colon-separated name, including the following parts:</p>
<ul>
<li>A number corresponding to the order of calculations. If you look at the gadget2 user-guide, consumption is step 3. This can be controlled using the <code>run_at</code> parameter of <code><a href="../reference/action_predate.html">g3a_predate_fleet()</a></code>, or any other action.</li>
<li>Another number specifying the order within an action this step should be performed.</li>
<li>The prey and where relevant the fleet name</li>
<li>A hash, that corresponds to the parameters of the <code><a href="../reference/action_predate.html">g3a_predate_fleet()</a></code> call.</li>
</ul>
<p>When a G3 model is made, it will sort the combined list of steps by name, and remove duplicates by name. This means that:</p>
<ul>
<li>Predation will happen at the correct part of the model cycle.</li>
<li>Predation steps themselves will be ordered. So all defined predation steps will collect their catch (<code>003:001</code>) before overconsumption is calculated (<code>003:004</code>). There’s no explict process needed to interleave multiple predation actions.</li>
<li>The overconsumption co-efficient for ling_imm will only be calculated once, regardless of the number of predation actions, since we will remove the duplicate versions of this step.</li>
<li>Conversely the hash ensures that there are never duplicate versions of the main predation step, so could be repated. This is more relevant for renewal, where there can be multiple renewal actions working on the same stock.</li>
</ul>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Jamie Lentin, Bjarki Thor Elvarsson.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
